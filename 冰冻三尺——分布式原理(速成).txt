博客地址：http://alaric.iteye.com/blog/2328144
保持数据一致性的六种方法：
	1.规避分布式事务————业务整合：
	业务整合方案主要采用将接口整合到本地执行的方法。问题场景：服务A、B、C整合为一个服务D给业务，
这个服务D再通过转换为本地事务的方式，比如服务D包含本地服务和服务E，而服务E是本地服务A~C的整合。
	优点：解决(规避)了分布式事务。
	缺点：显而易见，把本来规划拆分好的业务，又耦合到了一起，业务职责不清晰，不利于维护。


	2.经典方案———— eBay模式    http://article.yeeyan.org/view/167444/125572
	此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本
、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系
统对事后问题进行处理。
	消息日志方案的核心是保证服务接口的幂等性。
	考虑到网络通讯失败、数据丢包等原因，如果接口不能保证幂等性，数据的唯一性将很难保证。
	e-Bay方式的主要思路如下。
	Base：一种Acid的替代方案
	此方案是eBay的架构师写得一篇文章，是一篇解释BASE原则，或者说最终一致性的经典文章。文中讨论了
BASE与ACID原则在保证数据一致性的基本差异。
	如果ACID为分区的数据库提供一致性的选择，那么如何实现可用性呢？答案是BASE。BASE的可用性是通过
支持局部故障而不是系统全局故障来实现的。下面是一个简单的例子：如果将用户分区在5个数据库服务器上，
BASE设计鼓励类似的处理方式，一个用户数据库的故障只影响这台特定主机那20%的用户。这里不涉及任何魔法
，不过它确实可以带来更高的可感知的系统可用性。
	BASE应用示例。场景：
	如果产生了一笔交易，需要在交易表增加记录，同事还要修改用户表的金额。这两个表属于不同的远程服
务，所以就涉及到分布式事务一致性的问题。文中提出了一个经典的解决方法，将主要修改操作以及更新用户
表的消息放在一个本地事务来完成。同时为了避免重复消费用户表消息带来的问题，达到多次重试的幂等性，
增加一个更新记录表updates_applied来记录已经处理过的消息。
	基于以上方法，在第一阶段，通过本地的数据库的事务保障，增加了transaction表及消息队列。在第二阶
段，分别读出消息队列(但不删除)，通过判断更新记录表updates_applied来检测相关记录是否被执行，未被
执行的记录会修改user表，然后增加一条操作记录到updates_applied，事务执行成功之后再删除队列。

	
	3.去哪儿网分布式事务方案
	随着业务规模不断地扩大，电商网站一般都要面临拆分之路。就是将原来一个单体应用拆分成多个不同职
责的子系统。比如以前可能将面向用户、客户和运营的功能都放在一个系统里，现在拆分为订单中心、代理商管理、运营系统、报价中心、库存管理等多个子系统。
	拆分首先要面临的是什么呢？
	最开始的单体应用所有功能都在一起，存储也在一起。比如运营要取消某个订单，那直接去更新订单表状
态，然后更新库存表就ok了。因为是单体应用，库在一起，这些都可以在一个事务里，由关系数据库来保证一
致性。
	但拆分之后就不同了，不同的子系统都有自己的存储。比如订单中心就只管理自己的订单库，而库存管理
也有自己的库。那么运营系统取消订单的时候就说通过接口调用等方式来调用订单中心和库存管理的服务了，而不是直接去操作库。这就涉及一个"分布式事务"的问题。
	分布式事务有两种解决方式
	1.优先使用异步消息。
	上文已经说过，使用异步消息Consumer端需要实现幂等。
	幂等有两种方式：
	一种方式是业务逻辑保证幂等。比如接到支付成功的消息订单状态变成支付完成，如果当前状态是支付完
成，若再收到同一个请求支付的消息，说明消息重复了，直接作为消息成功处理。两个请求是否是同一个支付
。可以在支付消息中添加唯一标识来判断。
	另一种方式如果业务逻辑无法保证幂等，则要增加一个去重表或者类似的实现。对于producer端在业务数
据库的同实例上放一个消息库，发消息和业务操作在同一个本地事务里。发消息的时候消息并不立即发出，而
是向消息库插入一条消息记录，然后在事务提交的时候再异步将消息发出，发送消息如果成功则将消息库里的
消息删除，如果遇到消息队列服务异常或网络问题，消息没有成功发出，那么消息就留在这里了，会有另外一
个服务不断地将这些消息扫描并重新发送。
	2.有的业务不适合异步消息的方式，事务的各个参与方都需要同步的得到结果。
	这种情况的实现方式其实和上面类似，每个参与方的本地业务库的同实例上面放一个事务记录库。
	比如A同步调用B，C。A本地事务成功的时候更新本地事务记录状态，B和C同样。如果有一次A调用B失败了
，这个失败可能是B真的失败了，也可能是调用超时，实际B成功。则由一个中心服务对比三方的事务记录表，
做一个最终决定。假设现在三方的事务记录是A成功，B失败，C成功。那么最终决定有两种方式，根据具体
场景：1)重试B，直到B成功，事务记录表里记录了各项调用参数等信息； 2)执行A和B的补偿操作(一种可行
的补偿方式是回滚)。
	对于B的失败做一个特殊说明：比如B是扣库存服务，在第一次调用的时候因为某种原因失败了，但是重试
的时候库存已经变为0，无法重试成功，这个时候只有回滚A和C了。




