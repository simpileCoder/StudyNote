排序算法：
    1.冒泡排序
	像冒泡一样排序。
	
    2.插入排序
	类似打牌时将牌按大小顺序插好一样。
	数组中指定位置左侧的数是有序的，每次循环将右侧的一个数按顺序放入左侧。
	插入排序适合小规模数组排序。

    3.希尔排序
	分组插入排序。先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直
接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进
行一次直接插入排序。
	
	
	4.二叉树的前，中，后序遍历，递归写法
	//前序遍历  
    public void preOrder(TreeNode subTree){  
        if(subTree!=null){  
            visted(subTree);  
            preOrder(subTree.leftChild);  
            preOrder(subTree.rightChild);  
        }  
    }  
      
    //中序遍历  
    public void inOrder(TreeNode subTree){  
        if(subTree!=null){  
            inOrder(subTree.leftChild);  
            visted(subTree);  
            inOrder(subTree.rightChild);  
        }  
    }  
      
    //后续遍历  
    public void postOrder(TreeNode subTree) {  
        if (subTree != null) {  
            postOrder(subTree.leftChild);  
            postOrder(subTree.rightChild);  
            visted(subTree);  
        }  
    } 


------------------------------------------------------------------------------------

    M阶B树的特性：
    1.数据项存储在树叶上。
    2.非叶节点存储直到M-1个关键字以指示搜索的方向；关键字i代表子树i+1中的最小的关
键字。
    3.树的根或者是一片树叶，或者其儿子数在2和M之间。
    4.除根外，所有非树叶节点的儿子数在[M/2]和M之间。
    5.所有的树叶都在相同的深度上并有[L/2]和L之间个数据项，L的确定稍后描述。

------------------------------------------------------------------------------------

    散列表可能在散列扩大之后，可能会因为散列函数不准确导致位置靠后的散列不能被利
用。
    正确的散列函数：
    public static int hash(String key, int tableSize){
        int hashVal = 0;

        for(int i = 0; i < key.length(); i++){
            hashVal = 37 * hashVal + key.charAt(i);
        }

        hashVal = tableSize % hashVal;
        if(hashVal < 0)
        {
            hashVal = hashVal + tableSize
        }

        return hashVal;
    }

------------------------------------------------------------------------------------

    优先队列(堆)：至少包括两种操作：insert(入队操作)和deleteMin(出队操作)。
    1.链表实现
    简单链表的实现过程为在链表的头insert元素，使用O(1)时间完成，每次deleteMin元素，
查找出链表中最小的元素，花费O(N)时间完成；另外一种方法时让链表保持有序状态，在进行任
务insert的时候进行排序(花费O(N))，每次获取链表的头(花费O(1))。
    2.二叉查找树实现
    使用二叉查找树实现中，对insert和deleteMin花费时间均为O(log(N)),但存在一个潜在的
问题，因为每次删除始终是从左边开始往右边删除。容易造成不平衡二叉树。
    3.二叉堆实现
    二叉堆对于优先队列实现比较普遍，通二叉查找树一样，二叉堆具有两个性质：结构性和堆
序性。
    结构性：必须是一颗完全二叉树，树的插入从左到右，一颗完全二叉树的高度为小于log(N)
的最大整数。
    堆序性：二叉树的父节点必须小于两个子节点。

重要：
    在二叉堆的具体实现中，通过一个数组来存储所有的元素。一颗高度为h的完全二叉树有
2的h次方到2的h+1次方减一个节点。这意味着完全二叉树的高是logN向下取整。因为完全二叉树
这么有规律，所有它可以用一个数组表示而不需要使用链。
    对于数组中任一位置i上的元素，其左儿子在位置2i上，右儿子在左儿子后的单元(2i+1）中
，它的父亲则在i/2向下取整的位置上。


    二叉堆的基本操作：
    insert(插入):将一个元素X插入到堆中，我们在下一个可用位置创建一个空穴，否则该堆将
不是完全树。如果X可以放在该空穴中而不破坏堆的序，那么插入完成。否则，我们把空穴的父
节点上的元素移入该空穴中，这样，空穴就朝着根的方向上冒一步。继续该过程直到X能被放入
空穴中为止。
    deletMin(删除最小元):deleteMin以类似于插入的方式处理，找出最小元是很容易的，困难
之处是删除它。当删除一个最小元时，要在根节点建立一个空穴。由于堆中少了一个元素，因此
堆中最后一个元素X必须移动到该堆的某个地方。如果X可以被放到空穴中，那么deleteMin完成
。不过这一般不太可能，因此我们将空穴的两个儿子中较小者移入空穴，这样就把空穴向下推了
一层。重复该步骤直到X可以被放入空穴中。因此，我们的做法是将X置入沿着从根开始包含最小
儿子的一条路径上的一个正确的位置。

    