	在Java语言里面，类型的加载、链接和初始化过程都是在程序运行期间完成的，这种策略虽然会令
类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性。Java里天生可以动态扩展
的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。例如：如果编写一个面向接口的应用
程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个
本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应
用程序的方式目前已广泛应用于Java程序之中。
	
	类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载(Loading)、
验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initization)、使用(Using)
和卸载(Unloading)。

	类加载的过程
	1.加载
	“加载”是“类加载”过程的一个阶段，在加载阶段，虚拟机需要完成以下3件事情：
	1.通过一个类的全限定名来获取定义此类的二进制字节流。
	2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
	3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

	2.验证
	验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚
拟机的要求，并且不会危害虚拟机自身的安全。
	
	3.准备阶段
	准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区‘
中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括
类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java
堆中。其次，这里说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：
	public static int value = 123;
	那变量value在准备阶段过后的初始值是0，而不是123.因为这时候尚未开始执行任何java方法，而把
value赋值为123的动作将在初始化阶段才会执行。
	但是 public static final int value = 123; 会在准备阶段将value赋值为123.因为它是final修饰的。

	4.解析
	解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用是用符号来描述所引用的
目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
	直接引用：直接引用可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。

	5.初始化
	类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过
自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义
的Java程序代码。



类与类加载器
	类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于
任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载
器，都拥有一个独立的类名称空间。通俗的讲：比较两个类是否“相等”，只有在这两个类是由同一个类加载
器加载的前提下才有意义，否则，即使这两个类源于同一个Class文件，被同一个虚拟机加载，只要加载它们
的类加载器不同，那这两个类就必定不相等。
	从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，
这个类加载器使用C++语言实现，是虚拟机自身的一部分。另一种就是所有其他的类加载器，这些类加载器都
由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。
	从Java开发人员的角度看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统
提供的类加载器。
	1.启动类加载器(Bootstrap ClassLoader)：前面已经介绍过，这个类加载器负责将存放在<JAVA_HOME>\lib
目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。
启动类加载器无法被Java程序直接引用，用户子啊编写自定义类加载器时，如果需要把加载请求委派给引导类
加载器，那直接使用null代替即可。
	2.扩展类加载器(Extension ClassLoader)：这个加载器由这个加载器由sun.misc.Launcher$ExtClassLoader
实现。它负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，
开发者可以直接使用扩展类加载器。
	3.应用程序类加载器(Application ClassLoader)：这个类加载器由sun.misc.Launcher$AppClassLoader
实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类
加载器。它负责加载用户类路径(ClassPath)上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序
中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
	我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。

	双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个
请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层
的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，
子加载器才会尝试自己去加载。但双亲委派模型有三次被破坏。




	Class.getClassLoader()和Thread.currentThread.getContextClassLoader()的区别。
	1.Class.getClassLoader()这个获取的是Class这个类的类加载器。
	2.Thread.currentThread.getContextClassLoader()获取的是当前线程指定的类加载器。我们可以通过
Thread.currentThread.setContextClassLoader()可以为当前线程指定相应的ClassLoader。
